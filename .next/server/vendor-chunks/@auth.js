"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@auth";
exports.ids = ["vendor-chunks/@auth"];
exports.modules = {

/***/ "(rsc)/./node_modules/@auth/firebase-adapter/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@auth/firebase-adapter/index.js ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirestoreAdapter: () => (/* binding */ FirestoreAdapter),\n/* harmony export */   collectionsFactory: () => (/* binding */ collectionsFactory),\n/* harmony export */   getDoc: () => (/* binding */ getDoc),\n/* harmony export */   getOneDoc: () => (/* binding */ getOneDoc),\n/* harmony export */   initFirestore: () => (/* binding */ initFirestore),\n/* harmony export */   mapFieldsFactory: () => (/* binding */ mapFieldsFactory)\n/* harmony export */ });\n/* harmony import */ var firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase-admin/app */ \"firebase-admin/app\");\n/* harmony import */ var firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase-admin/firestore */ \"firebase-admin/firestore\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__, firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__]);\n([firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__, firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * <div style={{display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", padding: 16}}>\n *  <p>Official **Firestore** adapter for Auth.js / NextAuth.js, using the [Firebase Admin SDK](https://firebase.google.com/docs/admin/setup)</p>\n *  <a href=\"https://firebase.google.com/docs/firestore/\">\n *   <img style={{display: \"block\"}} src=\"/img/adapters/firebase.svg\" width=\"48\" />\n *  </a>\n * </div>\n *\n * ## Installation\n *\n * ```bash npm2yarn\n * npm install @auth/firebase-adapter firebase-admin\n * ```\n *\n * @module @auth/firebase-adapter\n */\n\n\nfunction FirestoreAdapter(config) {\n    const { db, namingStrategy = \"default\", collections = {}, } = config instanceof firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.Firestore\n        ? { db: config }\n        : { ...config, db: config?.firestore ?? initFirestore(config) };\n    const preferSnakeCase = namingStrategy === \"snake_case\";\n    const C = collectionsFactory(db, preferSnakeCase, {\n        users: \"users\",\n        sessions: \"sessions\",\n        accounts: \"accounts\",\n        verificationTokens: preferSnakeCase\n            ? \"verification_tokens\"\n            : \"verificationTokens\",\n        ...collections,\n    });\n    const mapper = mapFieldsFactory(preferSnakeCase);\n    return {\n        async createUser(userInit) {\n            const { id: userId } = await C.users.add(userInit);\n            const user = await getDoc(C.users.doc(userId));\n            if (!user)\n                throw new Error(\"[createUser] Failed to fetch created user\");\n            return user;\n        },\n        async getUser(id) {\n            return await getDoc(C.users.doc(id));\n        },\n        async getUserByEmail(email) {\n            return await getOneDoc(C.users.where(\"email\", \"==\", email));\n        },\n        async getUserByAccount({ provider, providerAccountId }) {\n            const account = await getOneDoc(C.accounts\n                .where(\"provider\", \"==\", provider)\n                .where(mapper.toDb(\"providerAccountId\"), \"==\", providerAccountId));\n            if (!account)\n                return null;\n            return await getDoc(C.users.doc(account.userId));\n        },\n        async updateUser(partialUser) {\n            if (!partialUser.id)\n                throw new Error(\"[updateUser] Missing id\");\n            const userRef = C.users.doc(partialUser.id);\n            await userRef.set(partialUser, { merge: true });\n            const user = await getDoc(userRef);\n            if (!user)\n                throw new Error(\"[updateUser] Failed to fetch updated user\");\n            return user;\n        },\n        async deleteUser(userId) {\n            await db.runTransaction(async (transaction) => {\n                const accounts = await C.accounts\n                    .where(mapper.toDb(\"userId\"), \"==\", userId)\n                    .get();\n                const sessions = await C.sessions\n                    .where(mapper.toDb(\"userId\"), \"==\", userId)\n                    .get();\n                transaction.delete(C.users.doc(userId));\n                accounts.forEach((account) => transaction.delete(account.ref));\n                sessions.forEach((session) => transaction.delete(session.ref));\n            });\n        },\n        async linkAccount(accountInit) {\n            const ref = await C.accounts.add(accountInit);\n            const account = await ref.get().then((doc) => doc.data());\n            return account ?? null;\n        },\n        async unlinkAccount({ provider, providerAccountId }) {\n            await deleteDocs(C.accounts\n                .where(\"provider\", \"==\", provider)\n                .where(mapper.toDb(\"providerAccountId\"), \"==\", providerAccountId)\n                .limit(1));\n        },\n        async createSession(sessionInit) {\n            const ref = await C.sessions.add(sessionInit);\n            const session = await ref.get().then((doc) => doc.data());\n            if (session)\n                return session ?? null;\n            throw new Error(\"[createSession] Failed to fetch created session\");\n        },\n        async getSessionAndUser(sessionToken) {\n            const session = await getOneDoc(C.sessions.where(mapper.toDb(\"sessionToken\"), \"==\", sessionToken));\n            if (!session)\n                return null;\n            const user = await getDoc(C.users.doc(session.userId));\n            if (!user)\n                return null;\n            return { session, user };\n        },\n        async updateSession(partialSession) {\n            const sessionId = await db.runTransaction(async (transaction) => {\n                const sessionSnapshot = (await transaction.get(C.sessions\n                    .where(mapper.toDb(\"sessionToken\"), \"==\", partialSession.sessionToken)\n                    .limit(1))).docs[0];\n                if (!sessionSnapshot?.exists)\n                    return null;\n                transaction.set(sessionSnapshot.ref, partialSession, { merge: true });\n                return sessionSnapshot.id;\n            });\n            if (!sessionId)\n                return null;\n            const session = await getDoc(C.sessions.doc(sessionId));\n            if (session)\n                return session;\n            throw new Error(\"[updateSession] Failed to fetch updated session\");\n        },\n        async deleteSession(sessionToken) {\n            await deleteDocs(C.sessions\n                .where(mapper.toDb(\"sessionToken\"), \"==\", sessionToken)\n                .limit(1));\n        },\n        async createVerificationToken(verificationToken) {\n            await C.verification_tokens.add(verificationToken);\n            return verificationToken;\n        },\n        async useVerificationToken({ identifier, token }) {\n            const verificationTokenSnapshot = (await C.verification_tokens\n                .where(\"identifier\", \"==\", identifier)\n                .where(\"token\", \"==\", token)\n                .limit(1)\n                .get()).docs[0];\n            if (!verificationTokenSnapshot)\n                return null;\n            const data = verificationTokenSnapshot.data();\n            await verificationTokenSnapshot.ref.delete();\n            return data;\n        },\n    };\n}\n// for consistency, store all fields as snake_case in the database\nconst MAP_TO_FIRESTORE = {\n    userId: \"user_id\",\n    sessionToken: \"session_token\",\n    providerAccountId: \"provider_account_id\",\n    emailVerified: \"email_verified\",\n};\nconst MAP_FROM_FIRESTORE = {};\nfor (const key in MAP_TO_FIRESTORE) {\n    MAP_FROM_FIRESTORE[MAP_TO_FIRESTORE[key]] = key;\n}\nconst identity = (x) => x;\n/** @internal */\nfunction mapFieldsFactory(preferSnakeCase) {\n    if (preferSnakeCase) {\n        return {\n            toDb: (field) => MAP_TO_FIRESTORE[field] ?? field,\n            fromDb: (field) => MAP_FROM_FIRESTORE[field] ?? field,\n        };\n    }\n    return { toDb: identity, fromDb: identity };\n}\nfunction getConverter(options) {\n    const mapper = mapFieldsFactory(options?.preferSnakeCase);\n    return {\n        toFirestore(object) {\n            const document = {};\n            for (const key in object) {\n                if (key === \"id\")\n                    continue;\n                const value = object[key];\n                if (value !== undefined) {\n                    document[mapper.toDb(key)] = value;\n                }\n                else {\n                    console.warn(`FirebaseAdapter: value for key \"${key}\" is undefined`);\n                }\n            }\n            return document;\n        },\n        fromFirestore(snapshot) {\n            const document = snapshot.data(); // we can guarantee it exists\n            const object = {};\n            if (!options?.excludeId) {\n                object.id = snapshot.id;\n            }\n            for (const key in document) {\n                let value = document[key];\n                if (value instanceof firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.Timestamp)\n                    value = value.toDate();\n                object[mapper.fromDb(key)] = value;\n            }\n            return object;\n        },\n    };\n}\n/** @internal */\nasync function getOneDoc(querySnapshot) {\n    const querySnap = await querySnapshot.limit(1).get();\n    return querySnap.docs[0]?.data() ?? null;\n}\nasync function deleteDocs(querySnapshot) {\n    const querySnap = await querySnapshot.get();\n    for (const doc of querySnap.docs) {\n        await doc.ref.delete();\n    }\n}\n/** @internal */\nasync function getDoc(docRef) {\n    const docSnap = await docRef.get();\n    return docSnap.data() ?? null;\n}\n/** @internal */\nfunction collectionsFactory(db, preferSnakeCase = false, collections) {\n    return {\n        users: db\n            .collection(collections.users)\n            .withConverter(getConverter({ preferSnakeCase })),\n        sessions: db\n            .collection(collections.sessions)\n            .withConverter(getConverter({ preferSnakeCase })),\n        accounts: db\n            .collection(collections.accounts)\n            .withConverter(getConverter({ preferSnakeCase })),\n        verification_tokens: db\n            .collection(collections.verificationTokens)\n            .withConverter(getConverter({ preferSnakeCase, excludeId: true })),\n    };\n}\n/**\n * Utility function that helps making sure that there is no duplicate app initialization issues in serverless environments.\n * If no parameter is passed, it will use the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to initialize a Firestore instance.\n *\n * @example\n * ```ts title=\"lib/firestore.ts\"\n * import { initFirestore } from \"@auth/firebase-adapter\"\n * import { cert } from \"firebase-admin/app\"\n *\n * export const firestore = initFirestore({\n *  credential: cert({\n *    projectId: process.env.FIREBASE_PROJECT_ID,\n *    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n *    privateKey: process.env.FIREBASE_PRIVATE_KEY,\n *  })\n * })\n * ```\n */\nfunction initFirestore(options = {}) {\n    const apps = (0,firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__.getApps)();\n    const app = options.name ? apps.find((a) => a.name === options.name) : apps[0];\n    if (app)\n        return (0,firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)(app);\n    return (0,firebase_admin_firestore__WEBPACK_IMPORTED_MODULE_1__.initializeFirestore)((0,firebase_admin_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(options, options.name));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGF1dGgvZmlyZWJhc2UtYWRhcHRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsZ0JBQWdCLHFGQUFxRjtBQUNyRztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzREO0FBQ3dDO0FBQzdGO0FBQ1AsWUFBWSxnREFBZ0QsSUFBSSxvQkFBb0IsK0RBQVM7QUFDN0YsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyw2QkFBNkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtEQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLGlCQUFpQiwyREFBTztBQUN4QjtBQUNBO0FBQ0EsZUFBZSxzRUFBWTtBQUMzQixXQUFXLDZFQUFtQixDQUFDLGlFQUFhO0FBQzVDIiwic291cmNlcyI6WyIvVXNlcnMvcmVhbHRvbnlwYXJrMi9EZXNrdG9wL2dvb2dsZS1oYWNrL25vZGVfbW9kdWxlcy9AYXV0aC9maXJlYmFzZS1hZGFwdGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogPGRpdiBzdHlsZT17e2Rpc3BsYXk6IFwiZmxleFwiLCBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsIHBhZGRpbmc6IDE2fX0+XG4gKiAgPHA+T2ZmaWNpYWwgKipGaXJlc3RvcmUqKiBhZGFwdGVyIGZvciBBdXRoLmpzIC8gTmV4dEF1dGguanMsIHVzaW5nIHRoZSBbRmlyZWJhc2UgQWRtaW4gU0RLXShodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9hZG1pbi9zZXR1cCk8L3A+XG4gKiAgPGEgaHJlZj1cImh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2ZpcmVzdG9yZS9cIj5cbiAqICAgPGltZyBzdHlsZT17e2Rpc3BsYXk6IFwiYmxvY2tcIn19IHNyYz1cIi9pbWcvYWRhcHRlcnMvZmlyZWJhc2Uuc3ZnXCIgd2lkdGg9XCI0OFwiIC8+XG4gKiAgPC9hPlxuICogPC9kaXY+XG4gKlxuICogIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogYGBgYmFzaCBucG0yeWFyblxuICogbnBtIGluc3RhbGwgQGF1dGgvZmlyZWJhc2UtYWRhcHRlciBmaXJlYmFzZS1hZG1pblxuICogYGBgXG4gKlxuICogQG1vZHVsZSBAYXV0aC9maXJlYmFzZS1hZGFwdGVyXG4gKi9cbmltcG9ydCB7IGdldEFwcHMsIGluaXRpYWxpemVBcHAgfSBmcm9tIFwiZmlyZWJhc2UtYWRtaW4vYXBwXCI7XG5pbXBvcnQgeyBGaXJlc3RvcmUsIGdldEZpcmVzdG9yZSwgaW5pdGlhbGl6ZUZpcmVzdG9yZSwgVGltZXN0YW1wLCB9IGZyb20gXCJmaXJlYmFzZS1hZG1pbi9maXJlc3RvcmVcIjtcbmV4cG9ydCBmdW5jdGlvbiBGaXJlc3RvcmVBZGFwdGVyKGNvbmZpZykge1xuICAgIGNvbnN0IHsgZGIsIG5hbWluZ1N0cmF0ZWd5ID0gXCJkZWZhdWx0XCIsIGNvbGxlY3Rpb25zID0ge30sIH0gPSBjb25maWcgaW5zdGFuY2VvZiBGaXJlc3RvcmVcbiAgICAgICAgPyB7IGRiOiBjb25maWcgfVxuICAgICAgICA6IHsgLi4uY29uZmlnLCBkYjogY29uZmlnPy5maXJlc3RvcmUgPz8gaW5pdEZpcmVzdG9yZShjb25maWcpIH07XG4gICAgY29uc3QgcHJlZmVyU25ha2VDYXNlID0gbmFtaW5nU3RyYXRlZ3kgPT09IFwic25ha2VfY2FzZVwiO1xuICAgIGNvbnN0IEMgPSBjb2xsZWN0aW9uc0ZhY3RvcnkoZGIsIHByZWZlclNuYWtlQ2FzZSwge1xuICAgICAgICB1c2VyczogXCJ1c2Vyc1wiLFxuICAgICAgICBzZXNzaW9uczogXCJzZXNzaW9uc1wiLFxuICAgICAgICBhY2NvdW50czogXCJhY2NvdW50c1wiLFxuICAgICAgICB2ZXJpZmljYXRpb25Ub2tlbnM6IHByZWZlclNuYWtlQ2FzZVxuICAgICAgICAgICAgPyBcInZlcmlmaWNhdGlvbl90b2tlbnNcIlxuICAgICAgICAgICAgOiBcInZlcmlmaWNhdGlvblRva2Vuc1wiLFxuICAgICAgICAuLi5jb2xsZWN0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCBtYXBwZXIgPSBtYXBGaWVsZHNGYWN0b3J5KHByZWZlclNuYWtlQ2FzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgY3JlYXRlVXNlcih1c2VySW5pdCkge1xuICAgICAgICAgICAgY29uc3QgeyBpZDogdXNlcklkIH0gPSBhd2FpdCBDLnVzZXJzLmFkZCh1c2VySW5pdCk7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0RG9jKEMudXNlcnMuZG9jKHVzZXJJZCkpO1xuICAgICAgICAgICAgaWYgKCF1c2VyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIltjcmVhdGVVc2VyXSBGYWlsZWQgdG8gZmV0Y2ggY3JlYXRlZCB1c2VyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGdldFVzZXIoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXREb2MoQy51c2Vycy5kb2MoaWQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0VXNlckJ5RW1haWwoZW1haWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRPbmVEb2MoQy51c2Vycy53aGVyZShcImVtYWlsXCIsIFwiPT1cIiwgZW1haWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0VXNlckJ5QWNjb3VudCh7IHByb3ZpZGVyLCBwcm92aWRlckFjY291bnRJZCB9KSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgZ2V0T25lRG9jKEMuYWNjb3VudHNcbiAgICAgICAgICAgICAgICAud2hlcmUoXCJwcm92aWRlclwiLCBcIj09XCIsIHByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIC53aGVyZShtYXBwZXIudG9EYihcInByb3ZpZGVyQWNjb3VudElkXCIpLCBcIj09XCIsIHByb3ZpZGVyQWNjb3VudElkKSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RG9jKEMudXNlcnMuZG9jKGFjY291bnQudXNlcklkKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVwZGF0ZVVzZXIocGFydGlhbFVzZXIpIHtcbiAgICAgICAgICAgIGlmICghcGFydGlhbFVzZXIuaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3VwZGF0ZVVzZXJdIE1pc3NpbmcgaWRcIik7XG4gICAgICAgICAgICBjb25zdCB1c2VyUmVmID0gQy51c2Vycy5kb2MocGFydGlhbFVzZXIuaWQpO1xuICAgICAgICAgICAgYXdhaXQgdXNlclJlZi5zZXQocGFydGlhbFVzZXIsIHsgbWVyZ2U6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0RG9jKHVzZXJSZWYpO1xuICAgICAgICAgICAgaWYgKCF1c2VyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlt1cGRhdGVVc2VyXSBGYWlsZWQgdG8gZmV0Y2ggdXBkYXRlZCB1c2VyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRlbGV0ZVVzZXIodXNlcklkKSB7XG4gICAgICAgICAgICBhd2FpdCBkYi5ydW5UcmFuc2FjdGlvbihhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IEMuYWNjb3VudHNcbiAgICAgICAgICAgICAgICAgICAgLndoZXJlKG1hcHBlci50b0RiKFwidXNlcklkXCIpLCBcIj09XCIsIHVzZXJJZClcbiAgICAgICAgICAgICAgICAgICAgLmdldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25zID0gYXdhaXQgQy5zZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAud2hlcmUobWFwcGVyLnRvRGIoXCJ1c2VySWRcIiksIFwiPT1cIiwgdXNlcklkKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0KCk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlKEMudXNlcnMuZG9jKHVzZXJJZCkpO1xuICAgICAgICAgICAgICAgIGFjY291bnRzLmZvckVhY2goKGFjY291bnQpID0+IHRyYW5zYWN0aW9uLmRlbGV0ZShhY2NvdW50LnJlZikpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25zLmZvckVhY2goKHNlc3Npb24pID0+IHRyYW5zYWN0aW9uLmRlbGV0ZShzZXNzaW9uLnJlZikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGxpbmtBY2NvdW50KGFjY291bnRJbml0KSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSBhd2FpdCBDLmFjY291bnRzLmFkZChhY2NvdW50SW5pdCk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgcmVmLmdldCgpLnRoZW4oKGRvYykgPT4gZG9jLmRhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudCA/PyBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB1bmxpbmtBY2NvdW50KHsgcHJvdmlkZXIsIHByb3ZpZGVyQWNjb3VudElkIH0pIHtcbiAgICAgICAgICAgIGF3YWl0IGRlbGV0ZURvY3MoQy5hY2NvdW50c1xuICAgICAgICAgICAgICAgIC53aGVyZShcInByb3ZpZGVyXCIsIFwiPT1cIiwgcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgLndoZXJlKG1hcHBlci50b0RiKFwicHJvdmlkZXJBY2NvdW50SWRcIiksIFwiPT1cIiwgcHJvdmlkZXJBY2NvdW50SWQpXG4gICAgICAgICAgICAgICAgLmxpbWl0KDEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY3JlYXRlU2Vzc2lvbihzZXNzaW9uSW5pdCkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gYXdhaXQgQy5zZXNzaW9ucy5hZGQoc2Vzc2lvbkluaXQpO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHJlZi5nZXQoKS50aGVuKChkb2MpID0+IGRvYy5kYXRhKCkpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24gPz8gbnVsbDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIltjcmVhdGVTZXNzaW9uXSBGYWlsZWQgdG8gZmV0Y2ggY3JlYXRlZCBzZXNzaW9uXCIpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRTZXNzaW9uQW5kVXNlcihzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBnZXRPbmVEb2MoQy5zZXNzaW9ucy53aGVyZShtYXBwZXIudG9EYihcInNlc3Npb25Ub2tlblwiKSwgXCI9PVwiLCBzZXNzaW9uVG9rZW4pKTtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXREb2MoQy51c2Vycy5kb2Moc2Vzc2lvbi51c2VySWQpKTtcbiAgICAgICAgICAgIGlmICghdXNlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB7IHNlc3Npb24sIHVzZXIgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdXBkYXRlU2Vzc2lvbihwYXJ0aWFsU2Vzc2lvbikge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXdhaXQgZGIucnVuVHJhbnNhY3Rpb24oYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblNuYXBzaG90ID0gKGF3YWl0IHRyYW5zYWN0aW9uLmdldChDLnNlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIC53aGVyZShtYXBwZXIudG9EYihcInNlc3Npb25Ub2tlblwiKSwgXCI9PVwiLCBwYXJ0aWFsU2Vzc2lvbi5zZXNzaW9uVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIC5saW1pdCgxKSkpLmRvY3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uU25hcHNob3Q/LmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2V0KHNlc3Npb25TbmFwc2hvdC5yZWYsIHBhcnRpYWxTZXNzaW9uLCB7IG1lcmdlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uU25hcHNob3QuaWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbklkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGdldERvYyhDLnNlc3Npb25zLmRvYyhzZXNzaW9uSWQpKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW3VwZGF0ZVNlc3Npb25dIEZhaWxlZCB0byBmZXRjaCB1cGRhdGVkIHNlc3Npb25cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRlbGV0ZVNlc3Npb24oc2Vzc2lvblRva2VuKSB7XG4gICAgICAgICAgICBhd2FpdCBkZWxldGVEb2NzKEMuc2Vzc2lvbnNcbiAgICAgICAgICAgICAgICAud2hlcmUobWFwcGVyLnRvRGIoXCJzZXNzaW9uVG9rZW5cIiksIFwiPT1cIiwgc2Vzc2lvblRva2VuKVxuICAgICAgICAgICAgICAgIC5saW1pdCgxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNyZWF0ZVZlcmlmaWNhdGlvblRva2VuKHZlcmlmaWNhdGlvblRva2VuKSB7XG4gICAgICAgICAgICBhd2FpdCBDLnZlcmlmaWNhdGlvbl90b2tlbnMuYWRkKHZlcmlmaWNhdGlvblRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmljYXRpb25Ub2tlbjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdXNlVmVyaWZpY2F0aW9uVG9rZW4oeyBpZGVudGlmaWVyLCB0b2tlbiB9KSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJpZmljYXRpb25Ub2tlblNuYXBzaG90ID0gKGF3YWl0IEMudmVyaWZpY2F0aW9uX3Rva2Vuc1xuICAgICAgICAgICAgICAgIC53aGVyZShcImlkZW50aWZpZXJcIiwgXCI9PVwiLCBpZGVudGlmaWVyKVxuICAgICAgICAgICAgICAgIC53aGVyZShcInRva2VuXCIsIFwiPT1cIiwgdG9rZW4pXG4gICAgICAgICAgICAgICAgLmxpbWl0KDEpXG4gICAgICAgICAgICAgICAgLmdldCgpKS5kb2NzWzBdO1xuICAgICAgICAgICAgaWYgKCF2ZXJpZmljYXRpb25Ub2tlblNuYXBzaG90KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHZlcmlmaWNhdGlvblRva2VuU25hcHNob3QuZGF0YSgpO1xuICAgICAgICAgICAgYXdhaXQgdmVyaWZpY2F0aW9uVG9rZW5TbmFwc2hvdC5yZWYuZGVsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gZm9yIGNvbnNpc3RlbmN5LCBzdG9yZSBhbGwgZmllbGRzIGFzIHNuYWtlX2Nhc2UgaW4gdGhlIGRhdGFiYXNlXG5jb25zdCBNQVBfVE9fRklSRVNUT1JFID0ge1xuICAgIHVzZXJJZDogXCJ1c2VyX2lkXCIsXG4gICAgc2Vzc2lvblRva2VuOiBcInNlc3Npb25fdG9rZW5cIixcbiAgICBwcm92aWRlckFjY291bnRJZDogXCJwcm92aWRlcl9hY2NvdW50X2lkXCIsXG4gICAgZW1haWxWZXJpZmllZDogXCJlbWFpbF92ZXJpZmllZFwiLFxufTtcbmNvbnN0IE1BUF9GUk9NX0ZJUkVTVE9SRSA9IHt9O1xuZm9yIChjb25zdCBrZXkgaW4gTUFQX1RPX0ZJUkVTVE9SRSkge1xuICAgIE1BUF9GUk9NX0ZJUkVTVE9SRVtNQVBfVE9fRklSRVNUT1JFW2tleV1dID0ga2V5O1xufVxuY29uc3QgaWRlbnRpdHkgPSAoeCkgPT4geDtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBGaWVsZHNGYWN0b3J5KHByZWZlclNuYWtlQ2FzZSkge1xuICAgIGlmIChwcmVmZXJTbmFrZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvRGI6IChmaWVsZCkgPT4gTUFQX1RPX0ZJUkVTVE9SRVtmaWVsZF0gPz8gZmllbGQsXG4gICAgICAgICAgICBmcm9tRGI6IChmaWVsZCkgPT4gTUFQX0ZST01fRklSRVNUT1JFW2ZpZWxkXSA/PyBmaWVsZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9EYjogaWRlbnRpdHksIGZyb21EYjogaWRlbnRpdHkgfTtcbn1cbmZ1bmN0aW9uIGdldENvbnZlcnRlcihvcHRpb25zKSB7XG4gICAgY29uc3QgbWFwcGVyID0gbWFwRmllbGRzRmFjdG9yeShvcHRpb25zPy5wcmVmZXJTbmFrZUNhc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvRmlyZXN0b3JlKG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiaWRcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFttYXBwZXIudG9EYihrZXkpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGaXJlYmFzZUFkYXB0ZXI6IHZhbHVlIGZvciBrZXkgXCIke2tleX1cIiBpcyB1bmRlZmluZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21GaXJlc3RvcmUoc25hcHNob3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gc25hcHNob3QuZGF0YSgpOyAvLyB3ZSBjYW4gZ3VhcmFudGVlIGl0IGV4aXN0c1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnM/LmV4Y2x1ZGVJZCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pZCA9IHNuYXBzaG90LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkb2N1bWVudFtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0RhdGUoKTtcbiAgICAgICAgICAgICAgICBvYmplY3RbbWFwcGVyLmZyb21EYihrZXkpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE9uZURvYyhxdWVyeVNuYXBzaG90KSB7XG4gICAgY29uc3QgcXVlcnlTbmFwID0gYXdhaXQgcXVlcnlTbmFwc2hvdC5saW1pdCgxKS5nZXQoKTtcbiAgICByZXR1cm4gcXVlcnlTbmFwLmRvY3NbMF0/LmRhdGEoKSA/PyBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRG9jcyhxdWVyeVNuYXBzaG90KSB7XG4gICAgY29uc3QgcXVlcnlTbmFwID0gYXdhaXQgcXVlcnlTbmFwc2hvdC5nZXQoKTtcbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBxdWVyeVNuYXAuZG9jcykge1xuICAgICAgICBhd2FpdCBkb2MucmVmLmRlbGV0ZSgpO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREb2MoZG9jUmVmKSB7XG4gICAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGRvY1JlZi5nZXQoKTtcbiAgICByZXR1cm4gZG9jU25hcC5kYXRhKCkgPz8gbnVsbDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0aW9uc0ZhY3RvcnkoZGIsIHByZWZlclNuYWtlQ2FzZSA9IGZhbHNlLCBjb2xsZWN0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJzOiBkYlxuICAgICAgICAgICAgLmNvbGxlY3Rpb24oY29sbGVjdGlvbnMudXNlcnMpXG4gICAgICAgICAgICAud2l0aENvbnZlcnRlcihnZXRDb252ZXJ0ZXIoeyBwcmVmZXJTbmFrZUNhc2UgfSkpLFxuICAgICAgICBzZXNzaW9uczogZGJcbiAgICAgICAgICAgIC5jb2xsZWN0aW9uKGNvbGxlY3Rpb25zLnNlc3Npb25zKVxuICAgICAgICAgICAgLndpdGhDb252ZXJ0ZXIoZ2V0Q29udmVydGVyKHsgcHJlZmVyU25ha2VDYXNlIH0pKSxcbiAgICAgICAgYWNjb3VudHM6IGRiXG4gICAgICAgICAgICAuY29sbGVjdGlvbihjb2xsZWN0aW9ucy5hY2NvdW50cylcbiAgICAgICAgICAgIC53aXRoQ29udmVydGVyKGdldENvbnZlcnRlcih7IHByZWZlclNuYWtlQ2FzZSB9KSksXG4gICAgICAgIHZlcmlmaWNhdGlvbl90b2tlbnM6IGRiXG4gICAgICAgICAgICAuY29sbGVjdGlvbihjb2xsZWN0aW9ucy52ZXJpZmljYXRpb25Ub2tlbnMpXG4gICAgICAgICAgICAud2l0aENvbnZlcnRlcihnZXRDb252ZXJ0ZXIoeyBwcmVmZXJTbmFrZUNhc2UsIGV4Y2x1ZGVJZDogdHJ1ZSB9KSksXG4gICAgfTtcbn1cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGhlbHBzIG1ha2luZyBzdXJlIHRoYXQgdGhlcmUgaXMgbm8gZHVwbGljYXRlIGFwcCBpbml0aWFsaXphdGlvbiBpc3N1ZXMgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gKiBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkLCBpdCB3aWxsIHVzZSB0aGUgYEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMU2AgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gaW5pdGlhbGl6ZSBhIEZpcmVzdG9yZSBpbnN0YW5jZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdGl0bGU9XCJsaWIvZmlyZXN0b3JlLnRzXCJcbiAqIGltcG9ydCB7IGluaXRGaXJlc3RvcmUgfSBmcm9tIFwiQGF1dGgvZmlyZWJhc2UtYWRhcHRlclwiXG4gKiBpbXBvcnQgeyBjZXJ0IH0gZnJvbSBcImZpcmViYXNlLWFkbWluL2FwcFwiXG4gKlxuICogZXhwb3J0IGNvbnN0IGZpcmVzdG9yZSA9IGluaXRGaXJlc3RvcmUoe1xuICogIGNyZWRlbnRpYWw6IGNlcnQoe1xuICogICAgcHJvamVjdElkOiBwcm9jZXNzLmVudi5GSVJFQkFTRV9QUk9KRUNUX0lELFxuICogICAgY2xpZW50RW1haWw6IHByb2Nlc3MuZW52LkZJUkVCQVNFX0NMSUVOVF9FTUFJTCxcbiAqICAgIHByaXZhdGVLZXk6IHByb2Nlc3MuZW52LkZJUkVCQVNFX1BSSVZBVEVfS0VZLFxuICogIH0pXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0RmlyZXN0b3JlKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFwcHMgPSBnZXRBcHBzKCk7XG4gICAgY29uc3QgYXBwID0gb3B0aW9ucy5uYW1lID8gYXBwcy5maW5kKChhKSA9PiBhLm5hbWUgPT09IG9wdGlvbnMubmFtZSkgOiBhcHBzWzBdO1xuICAgIGlmIChhcHApXG4gICAgICAgIHJldHVybiBnZXRGaXJlc3RvcmUoYXBwKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZUZpcmVzdG9yZShpbml0aWFsaXplQXBwKG9wdGlvbnMsIG9wdGlvbnMubmFtZSkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@auth/firebase-adapter/index.js\n");

/***/ })

};
;